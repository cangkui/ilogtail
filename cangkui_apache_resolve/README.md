<!--
 * @Author: cangkui 1843361355@qq.com
 * @Date: 2023-07-29 21:11:31
 * @LastEditors: cangkui 1843361355@qq.com
 * @LastEditTime: 2023-07-30 15:10:43
 * @FilePath: /home/csu_cangkui/Desktop/wuaolang.md
 * @Description: Alogrithm Design.
-->
# Apache 格式日志解析算法设计

Apache日志格式详见 [官网](https://httpd.apache.org/docs/2.4/mod/mod_log_config.html#page-header)

## 1. 算法思路

通过退化的有限自动机算法来处理每一条日志记录。

- 首先将输入的格式化字符串进行解析得到各个部分的组成成分（包含顺序）
- 其次根据每个组成成分 对日志记录进行解析，在遍历解析的过程中构造一个状态和顺序都固定的、有效的DFA进行识别（词法分析）得到单词
- 最后收纳整理结果

## 2. 算法流程

### 1.1 构造从描述符到函数指针的哈希映射

初始化时使用`unordered_map`构造一个从描述符到函数指针的哈希映射，每个格式描述符都对应一个函数作为状态处理函数。
这些函数需要根据描述符的不同特性设计针对性的算法进行解析，比如，`%s`和`%>s`作为状态码其长度必定为3位则直接截取3位子串作为`value`即可；`%t`作为时间显示是以`[`和`]`符号包围的固定长度字符串等等，尽量每个函数都做到 $O(1)$ 的复杂度。

### 1.2 解析输入的格式化字符串 `format`

以Apache日志为例，Apache官网给出了其日志的格式化规范，所有Apache产生的日志都是由格式化字符串解析替换形成的。
对于输入的格式化字符串进行解析，因为格式化规范当中所有的格式描述符都是以`%`号开头，因此可以直接使用顺序扫描解析得到。
一开始的想法是这里用DFA或者正则、%号分割等方式解析都可以，因为格式化字符串对比日志记录数据量非常小，遍历复杂度可以视作 $O(1)$.

### 1.3 构造DFA解析日志字符串

(1) 根据格式化描述符解析日志记录
遍历1.1节解析得到的（包含顺序的）描述符，并对日志记录执行解析。每个描述符需要执行的函数对应一个状态，每个状态之间单条件连接，当描述符遍历完毕后状态机进入结束状态。

(2) 遍历时收集解析到结果形成键值对存储。

### 1.4 流程图

![算法简要流程图](https://pic.imgdb.cn/item/64f6e305661c6c8e54a4f113.png)

# 回答疑惑

## 第一个问题：DFA的状态如何定义

DFA当中每一个状态对应主程序解析的对应描述符。由于主程序是先将描述符字符串`format`解析得到所有的描述符，再根据描述符按顺序解析日志内容，因此每读到一个描述符就对应一个状态，一个状态对应一个处理函数，用于解析该描述符对应的一段内容。

也就是说，（在主程序已经将`format`解析完成的情况下）从开始状态算起：

1. 每当主程序读取到一个描述符，则进入新状态，没有读取到则退出循环。
2. 此时新状态下执行对应该描述符的处理函数解析日志内容
3. 处理完毕后（收集结果），程序循环继续尝试读取描述符，回到步骤1.

在循环当中，**状态与状态之间的连接是固定的，实际上，在解析完format之后从开始到结束中间的每一个状态及其顺序就已经确定好了**。

可以看出，全部状态的类型与描述符的种类有关，可以按照描述符为状态编码1-n（假设日志提供方给出的规范当中，总共有n个描述符，或者所需要解析的日志可以用这n个描述符进行完备描述。可以设开始状态为0，结束状态为-1），建立描述符到状态编码的映射解决问题，同时也方便做哈希映射。状态与状态之间的转换表示可参考问题三。

## 第二个问题：处理函数及其传参问题

### 1 关于处理函数

每个描述符对应一个处理函数，我之前的文档是打算建立一个从描述符到处理函数的哈希映射，在某个状态下，通过映射调用该状态下对应的描述符 的处理函数来解析日志内容。

处理函数的目的是，定义在某个描述符的状态下，应该对日志字符串如何操作/截取来获得相应的解析结果。比如，随着处理日志字符串的进行，每个状态在日志字符串上会有一个位置`i`，指示当前解析到哪里了，那么处理函数就会以该位置为基准从该位置开始进行处理，处理完毕后得到结果并且修改`i`为结束位置作为下一轮解析的位置。

### 2 关于参数传递

以Apache的日志组成为例，至多额外传递一个参数。

- 大多数描述符对应情况下，不需要向处理函数传递额外参数，比如`%%`、`%a`、`%A`、`%B`等，只需要传递一个日志字符串的引用即可（当然，涉及到处理日志字符串的位置情况，可能还需要传一个位置参数，直接操作字符串性能可能受影响；另外，处理后得到的解析内容是作为函数结果返回更好还是通过参数引用修改更好可能要实际进行测试）。

- 其余情况，至多传递一个额外的参数，比如`%{VARNAME}i`、`%{VARNAME}C`、`%{format}P`等，需要将花括号内的参数进行额外传递。

也就是说，所有处理函数都必须传递某几个参数（日志字符串、当前解析位置等），而且所有处理函数要么返回string（处理结果）要么声明类型为void。部分处理函数必须额外传递一个参数，并且这个额外的参数类型为string。那么既然要声明一个哈希映射用于在某个状态下能够调用相应的处理函数进行处理，就需要考虑一些声明上的问题。

基于C++的声明特性，目前考虑有三种方式进行实现：

- 参数统一。所有函数都统一接收最大数目的参数传递，调用时，如果不需要传递这么多参数，则其余参数传空字符串`""`（或者默认参数）。该方法对函数定义造成冗余，并且有碍于可读性与可维护性；但是该方案直接调用原始函数，没有引入任何额外的包装或处理过程，性能上可能会好一点。
- 变长参数模板。这个方法是否能在定义哈希映射时不出问题我还没想清楚，要上手写才清楚。
- 结构体/类传参。即，所有的参数都封装到结构体/类当中，定义/声明哈希映射时，直接声明传递结构体/类的引用或者指针类型参数。该方案可读性与可维护性都还可以，同时支持在结构体/类当中进行预处理等操作。个人比较偏向于这个方案。

其中，目前打算是采用`std::functional`和`unordered_map`来声明哈希映射，比如下面这段代码：

```c++
#include <iostream>  
#include <unordered_map>  
#include <string> 
#include <functional>  

struct FunctionParams {
    std::string param1;
    std::string param2;
};    

std::string A(const FunctionParams& params) { 
    return params.param1; 
}

std::string B(const FunctionParams& params) { 
    return params.param1 + params.param2; 
}

std::string C(const FunctionParams& params) { 
    return params.param2 + params.param1; 
}

int main() {
    std::unordered_map<std::string, std::function<std::string(const FunctionParams&)> > x;
    FunctionParams params;
    params.param1 = "Hello";
    params.param2 = "World";
    
    x["funcA"] = A;
    x["funcB"] = B;
    x["funcC"] = C;
    
    std::cout << x["funcA"](params) << std::endl;
    std::cout << x["funcB"](params) << std::endl;
    std::cout << x["funcC"](params) << std::endl;
    return 0;
}
```

这里面还有一个问题：解析传入的`format`字符串的时候，遇到`%{C}a`、`%{VARNAME}C`、`%{format}P`等这些描述符应该如何处理/存储描述符与其中携带的参数（`C`、`VARNAME`、`format`）？最开始的想法是用二维数组`vector<pair<string, string> >`或者另外开一个`unordered_map`来存携带的参数，后来决定直接在参数结构体`params`当中新建一个参数即可。

## 第三个问题：为什么叫退化的DFA

这个可能是命名有误导（因为我第一想法是自动机后面发现有点不一样）。

因为在这篇设计当中，一旦传入的`format`被解析成了具有顺序的描述符集合，那么所有的状态及其顺序都已经被确定，并且状态与状态之间不需要转移条件，而是在上一个状态结束后就强制转移到下一个状态（一般而言DFA在状态转换时有可能是会要涉及到多个状态的转移选择，根据具体满足的条件来确定下一个状态）。

综上，个人认为本设计算不上一个典型的DFA，因此取名叫退化的DFA。
